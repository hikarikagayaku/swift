    ///     print(students)
    ///     // Prints "["Abena", "Akosua", "Kofi", "Kweku", "Peter"]"
    ///
    /// To sort the elements of your collection in descending order, pass the
    /// greater-than operator (`>`) to the `sort(by:)` method.
    ///
    ///     students.sort(by: >)
    ///     print(students)
    ///     // Prints "["Peter", "Kweku", "Kofi", "Akosua", "Abena"]"
    public mutating func sort()

    /// Returns the minimum element in the sequence.
    ///
    /// This example finds the smallest value in an array of height measurements.
    ///
    ///     let heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]
    ///     let lowestHeight = heights.min()
    ///     print(lowestHeight)
    ///     // Prints "Optional(58.5)"
    ///
    /// - Returns: The sequence's minimum element. If the sequence has no
    ///   elements, returns `nil`.
    ///
    /// - SeeAlso: `min(by:)`
    @warn_unqualified_access
    public func min() -> Element?

    /// Returns the maximum element in the sequence.
    ///
    /// This example finds the smallest value in an array of height measurements.
    ///
    ///     let heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]
    ///     let greatestHeight = heights.max()
    ///     print(greatestHeight)
    ///     // Prints "Optional(67.5)"
    ///
    /// - Returns: The sequence's maximum element. If the sequence has no
    ///   elements, returns `nil`.
    ///
    /// - SeeAlso: `max(by:)`
    @warn_unqualified_access
    public func max() -> Element?

    /// Returns a Boolean value indicating whether the sequence precedes another
    /// sequence in a lexicographical (dictionary) ordering, using the
    /// less-than operator (`<`) to compare elements.
    ///
    /// This example uses the `lexicographicallyPrecedes` method to test which
    /// array of integers comes first in a lexicographical ordering.
    ///
    ///     let a = [1, 2, 2, 2]
    ///     let b = [1, 2, 3, 4]
    ///
    ///     print(a.lexicographicallyPrecedes(b))
    ///     // Prints "true"
    ///     print(b.lexicographicallyPrecedes(b))
    ///     // Prints "false"
    ///
    /// - Parameter other: A sequence to compare to this sequence.
    /// - Returns: `true` if this sequence precedes `other` in a dictionary
    ///   ordering; otherwise, `false`.
    ///
    /// - Note: This method implements the mathematical notion of lexicographical
    ///   ordering, which has no connection to Unicode.  If you are sorting
    ///   strings to present to the end user, use `String` APIs that
    ///   perform localized comparison.
    /// - SeeAlso: `lexicographicallyPrecedes(_:by:)`
    public func lexicographicallyPrecedes<OtherSequence>(_ other: OtherSequence) -> Bool where OtherSequence : Sequence, OtherSequence.Iterator.Element == Element
}

extension Array where Element == String {

    /// Returns a new string by concatenating the elements of the sequence,
    /// adding the given separator between each element.
    ///
    /// The following example shows how an array of strings can be joined to a
    /// single, comma-separated string:
    ///
    ///     let cast = ["Vivien", "Marlon", "Kim", "Karl"]
    ///     let list = cast.joined(separator: ", ")
    ///     print(list)
    ///     // Prints "Vivien, Marlon, Kim, Karl"
    ///
    /// - Parameter separator: A string to insert between each of the elements
    ///   in this sequence. The default separator is an empty string.
    /// - Returns: A single, concatenated string.
    public func joined(separator: String = default) -> String
}

/// Returns `true` if these arrays contain the same elements.
public func ==<Element>(lhs: ContiguousArray<Element>, rhs: ContiguousArray<Element>) -> Bool where Element : Equatable

/// Returns `true` if the arrays do not contain the same elements.
public func !=<Element>(lhs: ContiguousArray<Element>, rhs: ContiguousArray<Element>) -> Bool where Element : Equatable

/// Returns `true` if these arrays contain the same elements.
public func ==<Element>(lhs: ArraySlice<Element>, rhs: ArraySlice<Element>) -> Bool where Element : Equatable

/// Returns `true` if the arrays do not contain the same elements.
public func !=<Element>(lhs: ArraySlice<Element>, rhs: ArraySlice<Element>) -> Bool where Element : Equatable

/// Returns `true` if these arrays contain the same elements.
public func ==<Element>(lhs: [Element], rhs: [Element]) -> Bool where Element : Equatable

/// Returns `true` if the arrays do not contain the same elements.
public func !=<Element>(lhs: [Element], rhs: [Element]) -> Bool where Element : Equatable

